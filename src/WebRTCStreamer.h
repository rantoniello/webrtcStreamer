/**
 */

#pragma once

#include <optional>
#include <chrono>
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <thread>
#include <cstring>
#include <rtc/rtc.hpp>
#include "utils/BlockingQueue.h"
#include "utils/SafeUMap.h"

using namespace std;

/**
 * @brief WebRTC point-to-multipoint media streamer.
 *
 * The WebRTCStreamer class implements a server-side WebRTC endpoint capable of
 * streaming real-time multimedia (audio/video/data) to multiple remote peers.
 * Each remote peer is represented by a dynamically created Client instance,
 * which manages its own PeerConnection, signaling queues, and state.
 *
 * ## Overview
 * - Acts as a **point-to-multipoint WebRTC streamer**.
 * - Accepts multiple remote consumers (peers).
 * - Creates/destroys Client objects dynamically during the WebRTC
 *   signaling lifecycle.
 * - Manages a shared global signaling WebSocket used to interface with a
 *   signaling server.
 * - Dispatches signaling messages to/from each Client through internal
 *   BlockingQueue objects.
 *
 * ## Client Lifecycle
 * - A new Client is created when a remote peer initiates a WebRTC session
 *   (during signaling).
 * - The Client persists as long as the remote peer stays connected.
 * - When the peer disconnects or signaling indicates closure,
 *   the Client instance is removed from the registry.
 *
 * ## Internal Communication
 * Each Client contains two thread-safe BlockingQueue<std::string> structures:
 * - `Client::_signalingQueueIn`  : Messages from WebRTCStreamer → Client.
 * - `Client::_signalingQueueOut` : Messages from Client → WebRTCStreamer.
 *
 * These queues are accessed through:
 * - Client::signalingSet()  → push a signaling message destined for the Client.
 * - Client::signalingGet()  → pop a signaling message produced by the Client,
 *                             optionally blocking with timeout.
 *
 * The queues provide safe asynchronous communication between the global
 * signaling thread and each individual Client instance.
 *
 * ## Thread Model
 * - WebRTCStreamer owns a dedicated signaling thread (`_signalingThread`),
 *   responsible for:
 *     - reading messages from the signaling server,
 *     - routing messages to the appropriate Client,
 *     - collecting outbound messages from Clients.
 * - Each Client may internally spawn or use additional WebRTC-specific threads
 *   (handled within rtc::PeerConnection events).
 */
class WebRTCStreamer {
public:
    /**
     * @brief Constructs a WebRTCStreamer object.
     * @param signalingServer URL or address of the signaling server used to
     *        coordinate WebRTC offer/answer and ICE candidate exchange.
     */
    WebRTCStreamer(const string& signalingServer);

    /**
     * @brief Destructor. Ensures all signaling threads and clients are cleanly
     * terminated.
     */
    ~WebRTCStreamer();

    void pushData(void *const data, size_t size);
private:

    /**
     * @brief Represents a single remote WebRTC consumer.
     * Each Client manages a single PeerConnection, its own signaling queues,
     * and communication state. It receives signaling messages from the
     * WebRTCStreamer and emits messages back to the streamer using
     * BlockingQueue<string>.
     */
    class Client
    {
    public:
        /**
         * @param stunServer STUN server URL used for ICE gathering.
         */
        Client(const string& id, const string& stunServer);

        ~Client();

        /**
         * @brief Pushes a signaling message destined for this Client.
         * This is typically called by the WebRTCStreamer to deliver messages
         * received from the signaling server.
         * @param message Signaling data (SDP, ICE candidate, etc.)
         */
        void signalingSet(string& message);

        /**
         * @brief Retrieves a signaling output message generated by the Client.
         * Blocks until either:
         *   - a message is available, or
         *   - the optional timeout expires.
         * @param timeout Maximum time to wait.
         * @return optional<string> The next signaling message from the Client,
         * or std::nullopt on timeout or shutdown.
         */
        optional<string> signalingGet(chrono::milliseconds timeout);

        /**
         * Send video(/audio) frame to remote peer.
         */
        void sendFrame(const byte *data, size_t size, rtc::FrameInfo info);

    private:
        /// Unique remote peer identifier.
        string _id;

        /// Underlying WebRTC PeerConnection for this client.
        shared_ptr<rtc::PeerConnection> _peerConnection;

        /// Video track
        shared_ptr<rtc::Track> videoTrack;

        /// Video track public interface access MUTEX
        shared_mutex _publicTrackMutex;

        /// Data track
        shared_ptr<rtc::DataChannel> dataChannel;

        /** @name Client's signaling Infrastructure
         *  Queues used for asynchronous communication with WebRTCStreamer.
         *  @{
         */
        BlockingQueue<string> _signalingQueueIn;
        ///< Incoming signaling messages.
        BlockingQueue<string> _signalingQueueOut;
        ///< Outgoing signaling messages.
        thread _signalingThread; ///< Optional per-client signaling thread.
        string _stunServer; ///< STUN server used for ICE candidate gathering.
        /** @} */

        /// Signals class instance termination
        atomic_bool _do_term;
    };

    shared_mutex _publicApiMutex; ///< Public interface access MUTEX
    atomic_bool _do_term; ///< Signals class instance termination

    /// Registry of active WebRTC clients indexed by peer ID.
    SafeUMap<string, Client> _clientsMap;

    /** @name Streamer global signaling Infrastructure
     *  Elements used to communicate with the external signaling server and
     *  internal client instances.
     *  @{
     */
    /// Address of the signaling server.
    string _signalingServer;

    /// Signaling WebSocket.
    shared_ptr<rtc::WebSocket> _signalingWS;

    /// Queue for i/o signaling messages.
    BlockingQueue<string> _signalingQueue;

    /// Main signaling processing method.
    void _signalingThr();

    /// Signaling thread, just executes '_signalingThr'
    thread _signalingThread;
    /** @} */

    /** @name Multimedia processing/sending related
     *  @{
     */
    struct Frame {
        Frame(void *data, size_t size, uint64_t sampleTime_usec) :
                buf(size),
                data(reinterpret_cast<const void*>(this->buf.data())),
                size(size),
                sampleTime_usec(sampleTime_usec)
        {
            if (data != nullptr && size > 0)
                memcpy(this->buf.data(), data, size);
        }
        vector<std::byte> buf;
        const void *data;
        size_t size;
        uint64_t sampleTime_usec;
    };
//    class Frame {
//    public:
//        Frame(void *data, size_t size, uint64_t sampleTime_usec) :
//                size(size),
//                buf(size),
//                data(reinterpret_cast<const void*>(this->buf.data())),
//                sampleTime_usec(sampleTime_usec)
//        {
//            if (data != nullptr && size > 0)
//                memcpy(this->buf.data(), data, size);
//        }
//        const void *data;
//        size_t size;
//        uint64_t sampleTime_usec;
//    private:
//        vector<std::byte> buf;
//    };

    /// Queue for input multimedia frames
    BlockingQueue<shared_ptr<WebRTCStreamer::Frame>> _framesQueueIn;

    /// Main multimedia processing method.
    void _multimediaThr();

    /// Main multimedia processing thread, just executes '_multimediaThr'.
    thread _multimediaThread;

    /// Private alias for 'WebRTCStreamer::pushData'.
    void _pushData(void *const data, size_t size);
    /** @} */

    // TODO: future control/status thread.
};
